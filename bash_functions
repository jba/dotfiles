# Display a window title.
function title {
  echo -e "\e]0;$1\a"
}


function euc {
  if [[ $2 == "" ]]; then
    echo >&2 "usage: euc USER REASON [mint]"
    return 1
  fi
  case $1 in
    *@*)
      local user=$1
      ;;
    *)
      local user=$1@google.com
  esac
  if [[ $3 == "mint" ]]; then
      local mintarg=-use_gaia_mint
  fi
  /google/data/ro/projects/tonic/admin_session \
        -tonic_backend default \
        -user $user \
        -tonic_policy skyloft-admin-tools \
        -delegates mdbgroup/codesite,mdbgroup/codesite-dev,mdbuser/$USER,mdbgroup/gerritcodereview-dev \
        -reason "$2" \
        $mintarg -- sh -c 'cp $END_USER_CREDS_FILE ~/euc.txt'
  export END_USER_CREDS_FILE=~/euc.txt
}

function is_single_change_client {
  g4 client -o | grep -q 'Options:.*nomultichange'
}

# Get the CL number generated by g4 change into a shell variable.
function newchange {
  if is_single_change_client; then
    read -e -i y -p "switch to multichange? (y/n) "
    if [[ $REPLY == "y" ]]; then
      g4 client --set_option multichange
    else
      return 1
    fi
  fi
  local cl=$(g4 change |& cut -d' ' -f 2)
  if [[ $? != 0 ]]; then
    return $?
  fi
  if [[ $cl == "files" ]]; then
    echo "No files in default changelist."
    return 1
  fi
  CL=$cl
  echo CL=$CL
}

function gocloud-test-project {
  if [[ $1 != "" ]]; then
    export GCLOUD_TESTS_GOLANG_PROJECT_ID=$1
    export GCLOUD_TESTS_GOLANG_KEY=/usr/local/google/home/jba/keys/$1.json
  fi
  echo "GCLOUD_TESTS_GOLANG_PROJECT_ID: $GCLOUD_TESTS_GOLANG_PROJECT_ID"
  echo "GCLOUD_TESTS_GOLANG_KEY: $GCLOUD_TESTS_GOLANG_KEY"
}

complete -W "$(for f in ~/keys/*; do basename $f .json; done)" gocloud-test-project

# git branch help:
# gb        list all branches
# gb E      if E exists, git co foo
# gb N      if N does not exist, confirm create, then git co -b
function gb {
  git-checkout-branch "$1" false
}

function gb! {
  git-checkout-branch "$1" true
}
  

function git-checkout-branch {
  local name=$1 force=$2
  if [[ $name == "" ]]; then
    git branch
  elif git rev-parse --verify -q "refs/heads/$name" > /dev/null; then
    git checkout "$name"
  elif $force; then
    git checkout -b "$name"
  else
    read -e -p "create? (y/n) "
    if [[ $REPLY == "y" ]]; then
      git checkout -b "$name"
    fi
  fi
}


function gb-complete {
  local prefix=$2 i=0
  for b in $(git branch); do
    if [[ $b == ${prefix}* ]]; then
      COMPREPLY[i++]=$b
    fi
  done
}

complete -F gb-complete gb

function gl {
  git lg -n 20 $*
  echo ...
}

# Run N copies of a command in series and wait for them to finish.
function ser {
  local N=$1
  shift
  for i in $(seq $N); do
    $*
  done
}

# Run N copies of a command in parallel and wait for them to finish.
function par {
  local N=$1
  shift
  # -N0 means don't pass any args to the command
  # -j0 means immediately start N processes
  parallel -N0 -j0 "$@" ::: $(seq $N)
}



# Code-review commands that work with both http-based and sso-based repos.
function cr {
  local originURL=$(git remote get-url origin)
  local http
  if [[ ${originURL:0:4} == "http" ]]; then
    http=true
  else
    http=false
  fi

  local prefix=""
  if [[ $1 == "-n" ]]; then
    prefix=echo
    shift
  fi

  cmd=$1
  shift
  case "$cmd" in
    new)
      $prefix git commit -a
      ;;
    change)
      if $http; then
        $prefix git cr change -a
      else
        $prefix git commit -a --amend
        fi
      ;;
    mail)
      if $http; then
        local revs=$(echo $* | tr ' ' ',')
	if [[ $revs != "" ]]; then
	   revs="-r $revs"
	   fi
        $prefix git cr mail $revs
      else
        local revs=$(echo $* | sed -r 's/\w+/r=&/g' | tr ' ' ',')
        if [[ $revs != "" ]]; then
          revs=%$revs
        fi
        $prefix git push origin HEAD:refs/for/master${revs}
      fi
      ;;
    *)
      echo >&2 "unknown command"
      return 1
  esac
}

function etags-go-subtree {
  etags $(find . -name '*.go')
}

function go16 {
  local root=$HOME/go1.6.4/go
  GOROOT=$root PATH=$root/bin:$PATH "$@"
}
